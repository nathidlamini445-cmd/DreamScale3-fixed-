import { NextRequest, NextResponse } from 'next/server';
import { getRewardConfig } from '@/lib/rewards/reward-config';
import { readFile } from 'fs/promises';
import { join } from 'path';
import { existsSync } from 'fs';

// Force dynamic rendering - this route uses request.url
export const dynamic = 'force-dynamic';

// Generate a well-formatted HTML document with template content (can be saved as PDF)
function generateTemplatePDF(title: string, content: string): Buffer {
  // Create HTML content that browsers can render and save as PDF
  const htmlContent = `<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>${escapeHTML(title)}</title>
  <style>
    @page {
      margin: 1in;
    }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
      line-height: 1.6;
      color: #333;
      max-width: 800px;
      margin: 0 auto;
      padding: 20px;
    }
    h1 {
      color: #39d2c0;
      border-bottom: 3px solid #39d2c0;
      padding-bottom: 10px;
      margin-bottom: 30px;
    }
    h2 {
      color: #2c3e50;
      margin-top: 30px;
      margin-bottom: 15px;
      border-left: 4px solid #39d2c0;
      padding-left: 15px;
    }
    h3 {
      color: #34495e;
      margin-top: 20px;
      margin-bottom: 10px;
    }
    p {
      margin-bottom: 15px;
    }
    ul, ol {
      margin-bottom: 15px;
      padding-left: 30px;
    }
    li {
      margin-bottom: 8px;
    }
    code {
      background: #f4f4f4;
      padding: 2px 6px;
      border-radius: 3px;
      font-family: 'Courier New', monospace;
    }
    .template-section {
      background: #f9f9f9;
      border-left: 4px solid #39d2c0;
      padding: 20px;
      margin: 20px 0;
      border-radius: 4px;
    }
    .footer {
      margin-top: 50px;
      padding-top: 20px;
      border-top: 2px solid #eee;
      text-align: center;
      color: #666;
      font-size: 12px;
    }
    strong {
      color: #2c3e50;
    }
  </style>
</head>
<body>
  <h1>${escapeHTML(title)}</h1>
  <div>${formatContentForHTML(content)}</div>
  <div class="footer">
    <p>Generated by DreamScale AI</p>
    <p>Thank you for being part of the DreamScale community!</p>
  </div>
</body>
</html>`;

  return Buffer.from(htmlContent, 'utf-8');
}

// Format markdown content for HTML
function formatContentForHTML(content: string): string {
  let formatted = content
    .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
    .replace(/\*(.*?)\*/g, '<em>$1</em>')
    .replace(/### (.*)/g, '<h3>$1</h3>')
    .replace(/## (.*)/g, '<h2>$1</h2>')
    .replace(/# (.*)/g, '<h2>$1</h2>')
    .replace(/`(.*?)`/g, '<code>$1</code>');

  // Handle lists
  const lines = formatted.split('\n');
  const processedLines: string[] = [];
  let inList = false;
  let listType = 'ul';

  for (let i = 0; i < lines.length; i++) {
    const line = lines[i].trim();
    
    if (/^\d+\.\s+/.test(line)) {
      // Numbered list
      if (!inList || listType !== 'ol') {
        if (inList) processedLines.push(`</${listType}>`);
        processedLines.push('<ol>');
        inList = true;
        listType = 'ol';
      }
      processedLines.push(`<li>${line.replace(/^\d+\.\s+/, '')}</li>`);
    } else if (/^-\s+/.test(line) || /^\*\s+/.test(line)) {
      // Bullet list
      if (!inList || listType !== 'ul') {
        if (inList) processedLines.push(`</${listType}>`);
        processedLines.push('<ul>');
        inList = true;
        listType = 'ul';
      }
      processedLines.push(`<li>${line.replace(/^[-*]\s+/, '')}</li>`);
    } else {
      if (inList) {
        processedLines.push(`</${listType}>`);
        inList = false;
      }
      if (line && !line.startsWith('<h') && !line.startsWith('</')) {
        processedLines.push(`<p>${line}</p>`);
      } else if (line) {
        processedLines.push(line);
      }
    }
  }
  
  if (inList) {
    processedLines.push(`</${listType}>`);
  }

  return processedLines.join('\n');
}

function escapeHTML(text: string): string {
  return text
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#039;');
}

// Generate placeholder HTML (fallback)
function generatePlaceholderPDF(title: string): Buffer {
  const htmlContent = `<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>${escapeHTML(title)}</title>
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      text-align: center;
      padding: 50px;
      color: #333;
    }
    h1 { color: #39d2c0; }
  </style>
</head>
<body>
  <h1>${escapeHTML(title)}</h1>
  <p>Thank you for redeeming this reward!</p>
  <p>This is a placeholder file. The full version will be available soon.</p>
  <p>DreamScale Team</p>
</body>
</html>`;
  
  return Buffer.from(htmlContent, 'utf-8');
}


// Validate download token (simple validation - in production use JWT)
function validateToken(token: string, rewardId: number): boolean {
  try {
    // Decode the token
    const decoded = Buffer.from(token, 'base64').toString('utf-8');
    const parts = decoded.split('-');
    
    // Token format: rewardId-userId-timestamp
    if (parts.length >= 1) {
      const tokenRewardId = parseInt(parts[0]);
      return tokenRewardId === rewardId;
    }
    return false;
  } catch (error) {
    return false;
  }
}

export async function GET(req: NextRequest) {
  try {
    const { searchParams } = new URL(req.url);
    const rewardIdParam = searchParams.get('rewardId');
    const token = searchParams.get('token');

    if (!rewardIdParam || !token) {
      return NextResponse.json(
        { error: 'Reward ID and token are required' },
        { status: 400 }
      );
    }

    const rewardId = parseInt(rewardIdParam);
    const rewardConfig = getRewardConfig(rewardId);

    if (!rewardConfig) {
      return NextResponse.json(
        { error: 'Invalid reward ID' },
        { status: 404 }
      );
    }

    // Validate token
    if (!validateToken(token, rewardId)) {
      return NextResponse.json(
        { error: 'Invalid or expired download token' },
        { status: 403 }
      );
    }

    // Check if file path exists
    if (!rewardConfig.filePath) {
      return NextResponse.json(
        { error: 'No file available for this reward' },
        { status: 404 }
      );
    }

    // Construct file path (remove leading slash for join)
    const filePath = rewardConfig.filePath.startsWith('/')
      ? rewardConfig.filePath.slice(1)
      : rewardConfig.filePath;
    
    const fullPath = join(process.cwd(), 'public', filePath);

    // Check if file exists
    if (!existsSync(fullPath)) {
      // File doesn't exist - generate real template using Bizora AI
      console.warn(`Reward file not found: ${fullPath}, generating real template with AI`);
      
      try {
        // Call the template generation API
        const generateResponse = await fetch(
          `${req.nextUrl.origin}/api/rewards/generate-template`,
          {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({ rewardId }),
          }
        );

        if (!generateResponse.ok) {
          throw new Error('Failed to generate template');
        }

        const { content, title } = await generateResponse.json();
        
        // Generate a well-formatted HTML document with the template content
        const htmlBuffer = generateTemplatePDF(title, content);
        const filename = filePath.split('/').pop()?.replace('.pdf', '.html') || 'download.html';
        
        return new NextResponse(htmlBuffer, {
          status: 200,
          headers: {
            'Content-Type': 'text/html',
            'Content-Disposition': `attachment; filename="${filename}"`,
            'Content-Length': htmlBuffer.length.toString(),
          },
        });
      } catch (error) {
        console.error('Error generating template:', error);
        // Fallback to placeholder if AI generation fails
        const htmlBuffer = generatePlaceholderPDF(rewardConfig.title);
        const filename = filePath.split('/').pop()?.replace('.pdf', '.html') || 'download.html';
        
        return new NextResponse(htmlBuffer, {
          status: 200,
          headers: {
            'Content-Type': 'text/html',
            'Content-Disposition': `attachment; filename="${filename}"`,
            'Content-Length': htmlBuffer.length.toString(),
          },
        });
      }
    }

    // Read and serve the file
    const fileBuffer = await readFile(fullPath);
    
    // Determine content type based on file extension
    const contentType = filePath.endsWith('.pdf')
      ? 'application/pdf'
      : filePath.endsWith('.xlsx')
      ? 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
      : filePath.endsWith('.xls')
      ? 'application/vnd.ms-excel'
      : 'application/octet-stream';

    // Get filename from path
    const filename = filePath.split('/').pop() || 'download';

    // Return file with appropriate headers
    return new NextResponse(fileBuffer, {
      status: 200,
      headers: {
        'Content-Type': contentType,
        'Content-Disposition': `attachment; filename="${filename}"`,
        'Content-Length': fileBuffer.length.toString(),
      },
    });
  } catch (error) {
    console.error('Error serving reward download:', error);
    return NextResponse.json(
      { error: 'Failed to serve download' },
      { status: 500 }
    );
  }
}
